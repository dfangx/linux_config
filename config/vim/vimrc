""""""""""""""""""""""""""""""""""""""""""""""""""
" VIMRC FILE
""""""""""""""""""""""""""""""""""""""""""""""""""
"
""""""""""""""""""""""""""""""""""""""""""""""""""
" XDG_CONFIG
""""""""""""""""""""""""""""""""""""""""""""""""""
set undodir=$XDG_CACHE_HOME/vim/undo
set directory=$XDG_CACHE_HOME/vim/swap
set backupdir=$XDG_CACHE_HOME/vim/backup
set viminfo+=n$XDG_CACHE_HOME/vim/viminfo
set runtimepath=$XDG_CONFIG_HOME/vim,$VIMRUNTIME,$XDG_CONFIG_HOME/vim/after

let $MYVIMRC='$XDG_CONFIG_HOME/vim/vimrc'
""""""""""""""""""""""""""""""""""""""""""""""""""
" SETTINGS
""""""""""""""""""""""""""""""""""""""""""""""""""
set path+=**                                " Set path for vim
set cursorline                              " Highlights line cursor is on
set lazyredraw                              " Redraw screen only when necessary
set showcmd                                 " Show command in bottom bar
set wildmenu                                " Turn on wildmenu
set wildignore+=*.bmp,*.gif,*.ico,*.png,*.pdf,*.psd
set showmatch                               " Highlight matching parenthesis
set backspace=indent,eol,start              " Backspace over everything in insert mode
set ruler                                   " Show cursor position all the time
set ttimeout                                " Time out for key codes
set ttimeoutlen=100                         " Wait up to 100ms after Esc for special key
set display=truncate                        " Show @@@ in last line if truncated
set scrolloff=5                             " Show a few lines of context around cursor
set showmode                                " Show mode in status bar
set autoindent                              " Autoindent
set pastetoggle=<F1>                        " Turn on paste mode when in insert mode
set hidden                                  " Hide files in background instead of closing them
set history=1000                            " Set undo limit to 1000
set writebackup                             " Protect against crash during write
set nobackup                                " Do not persist backup file after successful write
set undofile                                " Keep an undo file (undo changes after closing)
set incsearch                               " Do incremental searching when it's possible to timeout.
set hlsearch                                " Switch on highlighting the last used search pattern.
set foldenable                              " Enable code folding
set foldmethod=manual                       " Fold on indent
set foldlevelstart=0                        " Set starting fold level to 0
set number                                  " Display line numbers
set relativenumber                          " Display relative line numbers
set softtabstop=4
set shiftwidth=4
set expandtab                               " Convert tabs to spaces
set background=dark                         " Set background to dark
set splitbelow                              " New window splits on the bottom
set splitright                              " New window splits on the right side
set omnifunc=syntaxcomplete#Complete        " Enable omnicomplete
set autoread                                " Reread file when it is updated somewhere else
set encoding=utf-8
set scrolloff=1
set sidescrolloff=5
set laststatus=2
"set t_Co=256

filetype plugin on
filetype indent on                          " Indentation per filetype

""""""""""""""""""""""""""""""""""""""""""""""""""""
" KEYBINDINGS
""""""""""""""""""""""""""""""""""""""""""""""""""""
nnoremap <Space> <NOP>
let mapleader=" "   " Set leader key
let placeholder="<+++>"
let searchph="call search(placeholder)"
inoremap <c-j> <esc>:<c-r>=searchph<cr><cr>cf>
nnoremap <f2> :make<cr>

nnoremap <c-s> :w<cr>
inoremap <c-s> <c-o>:w<cr><esc>
inoremap jk <esc>

" File finding
nnoremap <leader>ff :find 
nnoremap <leader>fs :sfind 
nnoremap <leader>fv :vert :sfind 
nnoremap <leader>ft :tabfind 

" Split lines
nnoremap S a<cr><esc>
nnoremap <cr> i<cr><esc>
nnoremap <leader>o o<esc>

" Buffers
nnoremap <leader>n :bn<cr>
nnoremap <leader>p :bp<cr>
nnoremap <leader>b :ls<cr>:b<space>
nnoremap <leader>d :bd<cr>

" Surround
nnoremap <expr>cs({ BracketToCurly(matchstr(getline('.'), '\%' . col('.') . 'c.'))
nnoremap <expr>cs{( CurlyToBracket(matchstr(getline('.'), '\%' . col('.') . 'c.'))

" Move pane
nnoremap <silent> <leader>h <c-w>H
nnoremap <silent> <leader>l <c-w>L
nnoremap <silent> <leader>k <c-w>K
nnoremap <silent> <leader>j <c-w>J

" Split window
nnoremap <leader>s <c-w>s
nnoremap <leader>v <c-w>v
 
" Resize window
nnoremap <silent> <leader>< 10<c-w><
nnoremap <silent> <leader>> 10<c-w>>
nnoremap <silent> <leader>+ 10<c-w>+
nnoremap <silent> <leader>- 10<c-w>-

" Edit vimrc
nnoremap <leader>ev :tabnew $MYVIMRC<cr>
nnoremap <leader>rv :source $MYVIMRC<cr>

" Open terminal
nnoremap <leader>t :term<cr>
nnoremap <leader>T :vert term<cr>

cabbr Q q
cabbr Q! q!
cabbr W w

""""""""""""""""""""""""""""""""""""""""""""""""""""
" AUTOCOMMANDS
""""""""""""""""""""""""""""""""""""""""""""""""""""
" Put these in an autocmd group, so that you can revert them with:
" ":augroup vimStartup | au! | augroup END"
"
augroup vimStartup
    au!
    " When editing a file, always jump to the last known cursor position.
    " Don't do it when the position is invalid, when inside an event handler
    " (happens when dropping a file on gvim) and for a commit message (it's
    " likely a different one than last time).
    autocmd BufReadPost *
      \ if line("'\"") >= 1 && line("'\"") <= line("$") && &ft !~# 'commit'
      \ |   exe "normal! g`\""
      \ | endif
augroup END

augroup AutoMake
    autocmd!
"    if filereadable("Makefile")
"        autocmd BufWritePost *.h,*.c,*.cpp make
    autocmd QuickFixCmdPost * cwindow
"    endif
augroup END


augroup FileTypeRules
    autocmd!
    autocmd FileType markdown setlocal textwidth=80 " markdown settings
augroup END

""""""""""""""""""""""""""""""""""""""""""""""""""""
" FUNCTIONS
""""""""""""""""""""""""""""""""""""""""""""""""""""
function! Eatchar(pat)
    let c = nr2char(getchar(0))
    return (c =~ a:pat) ? '' : c
endfunction

function! GitBranch()
    let l:branch = system("git rev-parse --abbrev-ref HEAD 2>/dev/null | tr -d '\n'")
    if strlen(l:branch) > 0
        return '  ' . l:branch
    else
        return ''
    endif
endfunction

function! GitNumStage()
    let l:numStage = system('git ls-files -om --exclude-standard $(git rev-parse --show-toplevel)') 
    if l:numStage == ''
        return ''
    endif

    if  split(l:numStage)[0] == 'fatal:'
        return ''
    else
        return '[' . len(split(l:numStage, '\n')) . '] '
    endif
endfunction

function! IsGitRepo()
    let l:isRepo = system("git rev-parse --is-inside-work-tree | tr -d '\n'")
    if l:isRepo == 'true'
        return 1
    else
        return 0
    endif
endfunction

function! IsReadOnly()
    if &readonly
        return ''
    else
        return ''
    endif
endfunction

function! GetMode()
    let l:m = mode()
    if l:m == 'i'
        return 'INSERT'
    elseif l:m == 'v' || l:m == 'V' || l:m == "\<C-V>"
        return 'VISUAL'
    elseif l:m == 'R'
        return 'REPLACE'
    else
        return 'NORMAL'
    endif
endfunction

function! BracketToCurly(bracket)
    if a:bracket == '('
        return 'm1f)m2%r{`2r}`1'
    elseif a:bracket == ')'
        return 'm1F(m2%r}`2r{`1'
    else
        return ''
    endif
endfunction

function! CurlyToBracket(bracket)
    if a:bracket == '{'
        return 'm1f}m2%r(`2r)`1'
    elseif a:bracket == '}'
        return 'm1F{m2%r)`2r(`1'
    else
        return ''
    endif
endfunction
""""""""""""""""""""""""""""""""""""""""""""""""""""
" PLUGINS
"""""""""""""""""""""""""""""""""""""""""""""""""""
if empty(glob('$XDG_CONFIG_HOME/vim/autoload/plug.vim'))
    silent !curl -fLo $XDG_CONFIG_HOME/vim/autoload/plug.vim --create-dirs 
        \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif"

call plug#begin()
    Plug 'christoomey/vim-tmux-navigator'
    Plug 'tikhomirov/vim-glsl'
    Plug 'gkjgh/cobalt'
    Plug 'sjl/badwolf'
    Plug 'dracula/vim', {'as':'dracula'}
    Plug 'romainl/Apprentice'
    Plug 'morhetz/gruvbox'
call plug#end()

""""""""""""""""""""""""""""""""""""""""""""""""""""
" COLORS
""""""""""""""""""""""""""""""""""""""""""""""""""""
syntax enable                               " Enable syntax highlighting
colorscheme dracula                         " Use colorscheme cobalt

"if has("termguicolors")
"    set termguicolors
"    let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
"    let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
"endif
highlight Normal ctermbg=none
highlight StatusLine cterm=reverse,bold ctermfg=249 ctermbg=235
highlight StatusLineNC cterm=reverse,bold ctermfg=243 ctermbg=234
highlight User1 cterm=bold ctermfg=249 ctermbg=237

""""""""""""""""""""""""""""""""""""""""""""""""""""
" STATUS LINE
""""""""""""""""""""""""""""""""""""""""""""""""""""
set statusline=
set statusline+=%*
set statusline+=\ %{GetMode()}
set statusline+=%1*
set statusline+=

if IsGitRepo()
    set statusline+=%{GitBranch()}
    set statusline+=%{GitNumStage()}
    set statusline+=\ 
endif

set statusline+=\ %n:
set statusline+=\ %f
set statusline+=\ %m
set statusline+=\ %{IsReadOnly()}
set statusline+=%=
set statusline+=\ %{&fileencoding?&fileencoding:&encoding}
set statusline+=\ \[%{&fileformat}\]
set statusline+=\ 
set statusline+=\ %Y
set statusline+=\ 
set statusline+=\ %p%%
set statusline+=\ 
set statusline+=%*
set statusline+=\ \ %l:%c\ 
